"""Classes for storing science and model spectra.

TODO:
- Improve ProplydData.doppler_shift_data(): Manually shifting by integer values
  is not the best way to do this. It would be better to interpolate the data
  and perform a cross-correlation with a model to find the shift instead of
  asking for the shift as a parameter... Would need to account for nan values
  in the data.
- 
"""

import os
import numpy as np
from scipy.interpolate import interp1d
from fnmatch import fnmatch
from astropy.io import fits
from numpy.typing import NDArray
from scipy.signal import savgol_filter

class ProplydData:
    """Stores spectra of science targets.

    Attributes
    ----------
    x: nd_array
        Wavelength values.
    y: nd_array
        Flux density or normalized flux density.
    yerr: nd_array
        Uncertainty on y-values.
    name: str
        Name of the object.
    """

    def __init__(self, fname: str, name: str | None = None) -> None:
        """Initializes the ProplydData object by reading in data from
        a file.
        
        If the name is not specified, it will be set by splitting the file
        name by '.' and taking the first item in the resulting list. For example,
        the fname "OW94-154-346.merged.smoothed.fits" will result in the name
        "OW94-154-346".
        
        Parameters
        ----------
        fname: str
            File name containing proplyd data. Must be either a FITS file
            generated by Spextool or a normalized spectrum (.nspec).
        name: str or None, optional
            Name of the object. If None, this method will attempt to resolve
            the name of the object from the name of the file.
        """
        basename = os.path.basename(fname)
        abs_path = os.path.abspath(fname)

        if basename.endswith(".nspec"):
            data = np.loadtxt(fname).T
        elif basename.endswith(".fits"):
            data = fits.getdata(fname)
        else:
            raise ValueError(f"File type not recognized: {abs_path}")
        
        if name is None:
            self.name = basename.split('.')[0]
        else:
            self.name = name
        self.x = data[0]
        self.y = data[1]
        self.yerr = data[2]
        self.yerr_scaling = 1.0   # Add this line

    def get_range(self, xlo: float, xhi: float) -> tuple[ NDArray, NDArray, NDArray]:
        """Returns the spectrum confined to a range.

        Parameters
        ----------
        xlo: float
            Lower bound of the wavelength range.
        xhi: float
            Upper bound of the wavelength range.
        """
        mask = (self.x >= xlo) & (self.x <= xhi)
        return self.x[mask], self.y[mask], self.yerr[mask]
    
    def doppler_shift_data(self, shift: int, p: int = 50, fill_value: float = 1):
        """Applies a Doppler shift to the data. The y-values are padded with ones
        (or another fill_value) before rolling the array. Then, it is cropped
        back down to the original dimensions of y. This is also applied to yerr.

        Parameters
        ----------
        shift: int
            The number of pixels to shift the data.
        p: int, optional
            Amount to pad the data before shifting.
        fill_value: float, optional
            The value to fill the padding with.

        Returns
        -------
        None
        """
        y_pad = np.pad(self.y, p, constant_values=fill_value)
        yerr_pad = np.pad(self.yerr, p, constant_values=fill_value)
        self.y = np.roll(y_pad, shift)[p:-p]
        self.y_pad = np.roll(yerr_pad, shift)[p:-p]




    def rescale_yerr(self, factor: float):
        """
        Multiply all yerr values by a constant factor, and track cumulative scaling.

        Parameters
        ----------
        factor : float
            The multiplicative factor to apply to all elements of yerr.
        """
        self.yerr *= factor
        self.yerr_scaling *= factor
        print(f"[yerr rescaled] Factor applied: {factor}. Total scaling so far: {self.yerr_scaling}")

    def Nyquist_bin_spectrum(self, N: int = 3) -> tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Bin the spectrum by grouping every N pixels. Overwrites the object's
        wavelength, flux, and error arrays in place. The error is propagated as
        the standard error on the mean.

        Parameters
        ----------
        N : int
            Number of pixels to bin together.

        Returns
        -------
        x_binned : np.ndarray
            Mean wavelength per bin.
        y_binned : np.ndarray
            Mean flux per bin.
        yerr_binned : np.ndarray
            Error per binned pixel (quadrature sum divided by N).
        """
        npts = len(self.y)
        nbins = npts // N
        if nbins == 0:
            raise ValueError("Bin size N is too large for the number of data points.")
        x_binned = self.x[:nbins * N].reshape(-1, N).mean(axis=1)
        y_binned = self.y[:nbins * N].reshape(-1, N).mean(axis=1)
        yerr_binned = np.sqrt((self.yerr[:nbins * N].reshape(-1, N) ** 2).sum(axis=1)) / N

        print(f"[Nyquist sampling] Factor applied: {N}. Old SNR = {np.nanmedian(self.y/self.yerr)}")

        # Overwrite data in place
        self.x = x_binned
        self.y = y_binned
        self.yerr = yerr_binned

        print(f"[Nyquist sampling] Factor applied: {N}. New SNR = {np.nanmedian(self.y/self.yerr)}")

    def renormalize(self, factor: float):
        """
        Multiply all flux (y) and uncertainty (yerr) values by a constant normalization factor.
        This is used for re-normalizing the spectrum continuum level. The scaling is cumulative.

        Parameters
        ----------
        factor : float
            The normalization factor to apply to all elements of y and yerr.

        Returns
        -------
        None
        """
        self.y *= factor
        self.yerr *= factor
        self.yerr_scaling *= factor
        print(f"[renormalize] Spectrum and errors scaled by {factor}. Total flux scaling: {self.yerr_scaling}")

class ModelSpectrum:
    """Parent class to store a model spectrum.

    Attributes
    ----------
    Teff: float
        Effective temperature in Kelvin.
    logg: float
        Aurface gravity.
    rK: float
        Veiling factor.
    B: float
        Magnetic field strength in kG.
    vsini: float
        Rotational velocity in km/s.
    x: nd_array
        Wavelength values.
    y: nd_array
        Normalized flux density.
    """
    def __init__(self, Teff: float, logg: float, rK: float, B: float, vsini: float) -> None:
        """Initializes the ModelSpectrum object. Note that veiling is NOT applied
        until the method apply_veiling is called.
        """
        self.Teff = Teff
        self.logg = logg
        self.B = B
        self.rK = rK
        self.vsini = vsini
        self.x = np.zeros(0)
        self.y = np.zeros(0)

    def interpolate(self, xnew: NDArray) -> NDArray:
        """Interpolates the model to the new x-values.

        Parameters
        ----------
        xnew: array_like
            The new x-values to interpolate the model to.
        
        Returns
        -------
        out: nd_array
            The interpolated y-values at the new x-values.
        """
        xnew = np.array(xnew)
        itp = interp1d(self.x, self.y, kind="linear")
        return itp(xnew)
    
    def apply_veiling(self, rK: float) -> None:
        """Applies veiling to the model spectrum. This modifies the y-values.

        Parameters
        ----------
        rK: float
            The veiling factor to apply to the model.
        """
        self.rK = rK
        self.y = (self.y + rK) / (1 + rK)


class MoogStokesModel(ModelSpectrum):
    """MoogStokes models generated by Christian.

    References: Flores et al. (2019)
    """

    @staticmethod
    def region_xlims(region: int) -> tuple[float, float]:
        """Returns the wavelength limits of the specified region.

        Parameters
        ----------
        region: int
            Wavelength region.

        Returns
        -------
        xlims: tuple
            The wavelength limits of the region in Angstroms.
        """
        xlos = [21086, 21751, 21870, 22041, 22201, 22601, 22921]
        xhis = [21194, 21804, 21919, 22108, 22339, 22682, 23042]
        return xlos[region], xhis[region]
    
    def __init__(self, Teff: float, logg: float, rK: float, B: float, vsini: float,
                 region: int, models_dir: str = 'data/moog-stokes/') -> None:
        """
        
        Parameters
        ----------
        See ModelSpectrum.

        region: int
            Wavelength region.
        models_dir: str, optional
            Directory containing the model spectra.
        """
        super().__init__(Teff, logg, rK, B, vsini)
        self.models_dir = models_dir

        self.x, self.y = self.get_model_data(Teff, logg, B, vsini, region)
        self.apply_veiling(rK)
        self.x *= 1e4  # convert microns to Angstroms
    
    def get_model_data(self, Teff, logg, B, vsini, region):
        """Retrieves the wavelength, flux data of the MoogStokes model.
    
        Parameters
        ----------
        See ModelSpectrum.
        region: int
            Wavelength region.
    
        Returns
        -------
        x: ndarray
            Wavelength in microns.
        y: ndarray
            Normalized flux.
        """
        rK = 0  # we're going to manually apply veiling...
        Teff = int(Teff)
        logg = int(logg*100)
        vsini = int(vsini)

        dirname = 'iSHELL_0.75K2_T' + '{:d}'.format(Teff) + '_G' + '{:d}'.format(logg) \
             + "_Veil" + '{:.1f}'.format(rK) + '_Bf' + '{:.1f}'.format(B) \
             + '_vsin' + '{:d}'.format(vsini)
        basename = 'model_best_fit_params_wave_region_' + '{:d}'.format(region) + '.nspec'
        fname = os.path.join(self.models_dir, dirname, basename)

        if not os.path.exists(fname):
            # some of the folder names are formatted with floats for vsini... try this
            dirname = 'iSHELL_0.75K2_T' + '{:d}'.format(Teff) + '_G' + '{:d}'.format(logg) \
                + "_Veil" + '{:.1f}'.format(rK) + '_Bf' + '{:.1f}'.format(B) \
                + '_vsin' + '{:.1f}'.format(vsini)
            basename = 'model_best_fit_params_wave_region_' + '{:d}'.format(region) + '.nspec'''
            fname = os.path.join(self.models_dir, dirname, basename)

        x, y = np.loadtxt(fname).T
        return x, y
    
class BTSettlModel(ModelSpectrum):
    """Brown dwarf model spectra.

    References: Allard et al. 2011
    https://svo2.cab.inta-csic.es/theory/newov2/index.php?models=bt-settl-cifist
    """
    
    @staticmethod
    def nrefrac(wl, density=1.0):
        """Returns the refractive index of air from the Cauchy formula.

        This is a modified version of a function available on France Allard's
        website: https://phoenix.ens-lyon.fr/Grids/FORMAT

        Parameters
        ----------
        wl: array_like
            The wavelengths in Angstroms.
        density: float
            The density of air in amagat (relative to STP, e.g. ~10% decrease per 
            1000 m above sea level).
        """
        # The IAU standard for conversion from air to vacuum wavelengths is given
        # in Morton (1991, ApJS, 77, 119). For vacuum wavelengths (VAC) in
        # Angstroms, convert to air wavelength (AIR) via: 

        #  AIR = VAC / (1.0 + 2.735182E-4 + 131.4182 / VAC^2 + 2.76249E8 / VAC^4)
        wl2inv = (1e4/wl)**2
        refracstp = 272.643 + 1.2288 * wl2inv + 3.555e-2 * wl2inv**2
        n = (refracstp * density) * 1e-6 + 1
        return n
    
    def __init__(self, Teff: float, logg: float, rK: float, mode: str = 'k2', models_dir: str ='data/bt-settl-cifist/'):
        """Creates the BTSettlModel object.
        """
        super().__init__(Teff, logg, rK, B=0, vsini=0)
        self.models_dir = models_dir

        data = self.retrieve_norm_template(Teff, logg, mode)
        self.x = data[0]
        self.y = data[1]
        self.apply_veiling(rK)
    
    def retrieve_template_data(self, fname: str) -> tuple[NDArray, NDArray]:
        """Retrieves the wavelength, flux data from the brown dwarf model file.
    
        Parameters
        ----------
        fname: str
            The name of the file containing the template spectrum.
    
        Returns
        -------
        x: ndarray
            The wavelength data from the file.
        y: ndarray
            The flux density data from the file.
        """
        if fnmatch(fname, '*.nspec'):
            # Check to see if it's continuum normalized since the data are formatted
            # a bit differently. Additionally, the wavelengths are shifted to vacuum
            # when doing the continuum normalization.
            raw = np.loadtxt(fname).T
            x, y = raw[0,1:], raw[1,1:]     # Remove first element at wavelength = 0
        else:
            raw = np.loadtxt(fname, skiprows=8).T
            x, y = raw[0,1:], raw[1,1:]     # Remove first element at wavelength = 0
            x = x * self.nrefrac(x)         # Convert from air to vacuum wavelengths 
        return x, y
    
    def get_norm_template_fname(self, Teff: float, logg: float, mode: str) -> str:
        """Returns a string containing the name of the continuum normalized template
        file.
        
        Parameters
        ----------
        Teff: float
            The temperature in Kelvin.
        logg: float
            The surface gravity.
        mode: str
            The wavelength range of the models, which must be 'k2' or 'j3'.
        """
        pre = os.path.join(self.models_dir, mode)
        suf = '-0.0a+0.0.BT-Settl.spec.7.dat.nspec'
        fn = 'lte0' + '{:.1f}'.format(Teff/100) + '-' + '{:.1f}'.format(logg)
        return os.path.join(pre, fn + suf)
    
    
    def retrieve_norm_template(self, Teff: float, logg: float, mode: str) -> tuple[NDArray, NDArray]:
        """Retrieves the wavelength, flux data from a continuum normalized model
        brown dwarf spectrum given the temperature and surface gravity.
    
        Parameters
        ----------
        t: float
            The temperature in Kelvin.
        logg: float
            The surface gravity.
        mode: str
            The wavelength range of the models, which must be 'k2' or 'j3'.
        """
        fname = self.get_norm_template_fname(Teff, logg, mode)
        return self.retrieve_template_data(fname)